```js
const t = [1, -1, 3]

t.push(5)

console.log(t.length) // 4 is printed
console.log(t[1])     // -1 is printed

t.forEach(value => {
  console.log(value)  // numbers 1, -1, 3, 5 are printed, each on its own line
})                    
```

Example showcases how to use an array.  Note in the example the array was declared and stored to a const variable, but the array contents could be changed despite being initialize with const. This is because the reference of the variable cannot be changed, however the array's prosperities are free game. Think of changing the furniture in a spot of the house hold like a bed.

### Array Behavior
It basically works the same as arrays in other languages. 

- The index starts at zero corresponding to the first item
- the add item array.push(element)
- to get length array.length
- to index array[index]
- iterating through each element in the array.


arrays have foreach method. In the example for reach receives a function defined using the arrow syntax as parameter to iterate through each item.
```js
value => {
  console.log(value)
}
```
'foreach' calls the function passing each element as an argument into the arrow function. Note the function as the argument forEach can also receive other arguments. 


## Additional Arguments

While your example shows a callback function that only uses the `value` parameter, `forEach()` can actually provide up to three arguments to the callback function [2](https://codesweetly.com/javascript-foreach-method/):

1. **currentValue**: The current element being processed in the array (required).
2. **index**: The index of the current element being processed (optional).
3. **array**: The array that `forEach()` is being applied to (optional).

```js
const fruits = ['apple', 'banana', 'cherry'];

fruits.forEach((value, index, array) => {
  console.log(`${index}: ${value}`);
  console.log(`Array length: ${array.length}`);
});

```


Instead of using push we want to use concat. This is since react follows an ideology borrowed from functional programming that things defined cannot be changed *immutable data strctures*. Instead we want to use concat to ensure the original array is not altered and creating a new array with the added item.

```js
const t = [1, -1, 3]
const t2 = t.concat(5)  // creates new array
console.log(t)  // [1, -1, 3] is printed
console.log(t2) // [1, -1, 3, 5] is printed
```


```js
const t = [1, 2, 3]

const m1 = t.map(value => value * 2)
console.log(m1)   // [2, 4, 6] is printed
```
 Looking at this block of code we see that again like the previous code an operation was performed to create a new array with the contents of the old plus the new changes without effecting the old array. In the code above we see the usuage of the map function. The map function takes in an argument which is a function that is applied to  all the elements in the array. The map function applies something (in this case  value*2) to create a new array



```js
const m2 = t.map(value => '<li>' + value + '</li>')
console.log(m2)  
// [ '<li>1</li>', '<li>2</li>', '<li>3</li>' ] is printed
```
Interesting example where the original and the new list contains totally different things. First array is an array of ints and the second array is of string containing the value wrapped by the li tag.


### Destructing Assignment

This is like JavaScript's ability to make assumptions or fill in what you wanted to do with arrays without fully expressing them. This works in a couple of cases.

```js
const t = [1, 2, 3, 4, 5]

const [first, second, ...rest] = t

console.log(first, second)  // 1, 2 is printed
console.log(rest)          // [3, 4, 5] is printed
```
observe that the left hand side is an array. This usually means you're assigning an array variable a reference however, this is certainly not the case and is assigning each  variable a value in respect to the array on the right hand side (vals in indexes on the right hand side are mapped to the left). Now also observe that there's ...rest. This is interesting because the first two variables are defined and save a single int value. Rest on the other hand like it's name implies stores the rest of the data that hasn't been stored to an explicitly named variable and it's an array.


### Other Use Cases

**Skipping Elements**:
```js
const t = [1, 2, 3, 4, 5];
const [first, , third] = t; // Skip the second element
console.log(first, third);  // Outputs: 1 3

```

**Default Values**:
```js
const t = [1];
const [first, second = 10] = t;
console.log(first, second);  // Outputs: 1 10
```

**Nested Arrays**:
```js
const t = [1, [2, 3], 4];
const [first, [second, third], fourth] = t;
console.log(first, second, third, fourth);  // Outputs: 1 2 3 4

```

### Saving arrays by reference
```js
const t = [1, 2, 3, 4, 5];
const c = t;

c[0] = 100; // Modify the first element using `c`

console.log(t); // Outputs: [100, 2, 3, 4, 5]
console.log(c); // Outputs: [100, 2, 3, 4, 5]

```

c saves the reference to the array t instead of creating a new array. 


### If You Want a New, Independent Array:

Spread Syntax
```js
const t = [1, 2, 3, 4, 5];
const c = [...t];

c[0] = 100;

console.log(t); // Outputs: [1, 2, 3, 4, 5]
console.log(c); // Outputs: [100, 2, 3, 4, 5]

```

Using Array.slice()
```js
const t = [1, 2, 3, 4, 5];
const c = t.slice();

c[0] = 100;

console.log(t); // Outputs: [1, 2, 3, 4, 5]
console.log(c); // Outputs: [100, 2, 3, 4, 5]

```

**Using `Array.from()`**:
```js
const t = [1, 2, 3, 4, 5];
const c = Array.from(t);

c[0] = 100;

console.log(t); // Outputs: [1, 2, 3, 4, 5]
console.log(c); // Outputs: [100, 2, 3, 4, 5]

```